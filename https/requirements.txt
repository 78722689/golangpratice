1、题目说明

* 使用 Golang 开发一个 HTTPS Web 服务器/客户端
	* 服务端使用 TLS 的自签证书，客户端忽略安全性即可，不关心浏览器是否可以访问该网站
	* 服务端维护一个内存数据结构，所有数据进程重启丢失，不做数据持久化，不考虑内存容量问题
	* 服务端实现一个网络 API 接口，客户端向该 API 发送一个网络请求，请求内容是一个 []string 的信息
	* 服务端该 API 收到请求后响应一个 []bool 的信息，告知客户端发送的数组中对应下标的字符串是否之前已经发送过了
		* 传入和传出的数组长度一致
		* 服务器进程启动后，第一次收到某个字符串，返回 false，第二次及以上再收到这个字符串，返回 true
		* 如果一次传入的数组里面有重复的字符串的情况，要求从前向后依次处理，不允许一次请求数值里面的重复字符串都返回 false。
		* 注意该服务端代码，不可以写在自动测试文件里面
		* 注意服务端/客户端之间通讯必须使用 https 协议。不接受直接使用tls协议，不接受直接使用tcp协议。
		* 注意服务端代码部分，任何情况下均不能退出进程。
	* 必须写一个 Golang 的客户端函数（该函数后面简称 BcjClient ），调用该服务端的 API 接口
		* 该客户端函数输入类型为：[]string，输出类型为： []bool，和 error
		* 内部构造网络请求，通过 HTTPS 发送给服务端，并处理服务端的响应
		* 注意该函数不可以写在自动测试文件里面
		* 客户端函数是个function/函数，不是method/方法
		* 注意客户端代码部分，任何情况下均不能退出进程。
        * 客户端函数的类型必须严格匹配。
	* 必须使用 Golang 的测试框架写一个自动测试：在当前进程启动服务端后，客户端在同一个进程向服务端发送若干请求去测试客户端/服务端的代码正确性
		* 自动测试至少需要测试一种正常执行的情况，验证客户端函数返回的 []bool 的每一项的内容符合预期，输入写死，预期写死，不能使用程序计算出来
		* 必须验证客户端函数返回的 error 的内容符合预期，预期写死，不允许忽略error 的返回值。
		* 自动测试必须使用代码自行判断内部逻辑是否正确，不接受输出到控制台人工判断结果是否正确
		* 自动测试可以采用某种方式清空内部缓存数据（可选择是否实现）
		* 自动测试无法编译/报错则机试不通过
		* 在自动测试中调用客户端和服务端
		* 自动测试的客户端/服务端必须在同一个进程（不允许在自动测试里面开一个进程，不允许要求调用者手动开进程）
		* 至少有一个自动测试去测试客户端函数 BcjClient。
		* 自动测试必须使用 Golang 自带的自动测试框架，验证笔试结果时会通过 Golang 的自动测试框架开始运行代码，不接受除此之外的任何手动操作
		* 自动测试至少需要包含一个测试用例
		* 自动测试运行时间超过10秒，机试不通过
		* 如果 package 里面有多个自动测试入口，必须保证每一个自动测试入口单独运行测试正常不报错
		* 自动测试反复运行都应该结果正确
		* 自动测试时，服务端不能监听 1024及以下的端口号（比如443），以避免mac非root权限无法运行。
		* 自动测试时，禁止由于服务端listen和客户端dial调用前后顺序不确定，造成可能的dial失败。

* 源码提交要求
	* 将所有源代码压缩成一个 zip 文件，保留 GOPATH 下的所有目录结构（**zip 的根目录下应该有个 src 目录**）
	* zip 文件体积不允许超过 1MB（注意只把 Golang 源文件/体积小的资源文件放在里面，其他文件特别是编译后的二进制不要放在里面）
	* zip 压缩包必须包含除了 Golang 官方包以外的所有代码依赖
	* 提交非zip文件则笔试不通过。zip文件无法成功解压则笔试不通过。

* 编译要求
	* 代码中不能使用cgo。并且能在关闭cgo下编译运行成功。
	* 该 Golang 代码需要能在 Golang 1.9 到 golang.org 最新的正式版本之间的某个 版本下编译运行测试，如果您的代码在 golang 1.9 下无法运行/不能确认是否可以运行，请给出您可以运行的 golang版本。不接受未发布的测试的golang版本。
	* 代码应当同时兼容 MacOS/Linux/Windows 桌面平台
	* 是否有 go.mod 文件不影响笔试结果。

* 代码要求
	* 代码不能抄袭，可以调用官方库代码，但不能包含其他第三方代码（比如 github.com/xxx）
	* 所有代码应该写在一个 Golang 的 package 里面
	* GOPATH 里面必须只有一个 package （不允许开第二个 package）
	* 只允许使用目录作为一个 package，不允许使用单个文件作为一个 package
		* 同一个目录里面只能有一个 package 的名字
		* 比如 main 或者 zzServer，不可以有第二个
		* 同一个目录里面不允许有相同的函数名，比如写两个 main 函数等等
	* 可以写一个 main 函数，也可以不写 main 函数，对机试结果无影响
	* 必须能使用 GOPATH=xxx go install xxx(import path) 方式直接编译
	* 注意后面必须写一个 import path 路径，写一个文件是否能编译对机试结果无影响
	* 禁止把 Golang 文件直接放在 GOPATH/src 目录下.
	* 不允许放 Golang 文件的上一级目录名称为 main 或者 src.
	* 实现应当简洁，代码可读性不能过差
		* 代码是用来解决问题的，是工程，不是诗，不是艺术， 追求的是正确，严谨，可靠和性能，不是追求艺术性或者美感
		* 反对照搬式的套设计模式，套面向对象，套数据库范式等，应当追求正确性，代码低复杂度，高性能，而不是被流行／流派蒙蔽了智慧
		* 反对为了高内聚低耦合而过早封装
	* 具体以审核人员阅读为准（注意本次机试不关心性能和可扩展性）
		* 例如：不要定义只有一个实现者的 interface
		* 例如：不要将只被调用过一次，并且只有一行的简单函数单独封装出来
		* 例如：不要写无意义的 channel 逻辑
		* 例如：应当少用 fmt.Sprintf
	* 可选要求：
		* 自动测试的行代码覆盖率越高，机试结果越好
		* 代码可读性越高，机试结果越好（注意本次机试不关心性能和可扩展性）
* 运行要求
	* 代码运行结果应当正确
	* 代码中不允许存在任何忽略错误的情况。
	* 不应该有 data race（race condition/竞争条件）
	* 多线程客户端调用服务端时，不应当出现任何同一个字符串返回多个 false 的可能性
	* 需要满足 Database transaction（数据库事务）的 Serializability（可串行性）要求
	* 注意：Golang 的 data race 工具只能找到部分 data race 情况